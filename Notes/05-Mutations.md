# 05. Mutations

Simillar to how we query data, we can perform other operations in the graphQL backend [ Update/Delete/Add ]. We use special type called *Query* to fetch the data. Similarly, we will use a special type called **Mutation** to perform these operations.

Simillar to the Query type, we need to add entry points in the mutation type and speicify the return type.

**Example**

Adding an entry point to delete a specific game.

	type Mutation{
			deleteGame(id:ID!):[Game]
		}
	
deleteGame takes id as an input and return the list of remaining games as the response to the end user. Now, we need to add a resolver function the deleteGame entry-point. Simillar to how we write resolver functions for queries within Query object, we need to write the resolver functions in Mutation Object as below.

	Mutation:{
			deleteGame(_,args){
					db.games  =  db.games.filter((game) =>  game.id  !==  args.id);
					return  db.games;
				}
		}

**Testing the Mutation entrypoint** in Apollo Explorer

	mutation  CrudQuery($id:ID!){
		deleteGame(id:$id){
			name,
			platform,
			reviews{
				rating,
				author{
					name
					}
				}
			}
		}

*Variables* 

Deleting the game object with id 3 and retrieving the name and platform properties of the remaining games along with the related ratings & author name.

	{
	  "id":"3"
	}

### Adding the Data

To add the data using graphQL queries, we need to define the entry point in mutation type and define a resolver function for that entry point as before. But, to add the data we need to recieve data from the user and for that we need to define the type of data we want to receive as part of the request for that specific entrypoint.

We have a special type called **input** which can be used to declare a custom type which can be used as a input parameter in the entry point defintion.

**Example**

If we want to add a new game to the list of game objects, we need to get the game name and the list of platforms as the input. Usually id will be generated by db automatically. Here, we want to simulate that. So, we take name and list of platforms as the input from the user and we will generate the id manually.

Define the input type as follows.

	input gameInput{
		name:String!
		platform:[String!]!
	}

Create an entry point in mutation type to receive the gameInput as input from the user that returns the list of total games.

	type Mutation{
		// existing code
		addGame(game:gameInput!):[Game]
	}

**Resolver Function**

	Mutation:{
		//existing code
		addGame(_,args){
			db.games=[...db.games, 
					  {...args.game,id:(db.games.length+1).toString()}]
			}
			return db.games;
	}

**Testing**

	mutation updateQuery($game:gameInput!){
		addGame(game:$game){
			id,
			name,
			platform,
			reviews{
				rating
			}
		}
	}

*input*

	{"game":{"name:"Quantum Break","platform":["xbox","pc"]}}


